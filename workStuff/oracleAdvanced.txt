/*subquery*/
select * from ( select * from employees order by salary desc ) where rownum <= 3;

select first_name, last_name,department_id from employees where department_id in (select department_id from departments where location_id=1700);

/*correlated subqueries*/
select employee_id,salary,department_id from employees t1 
where salary > ( select avg(salary) from employees t2 where t1.department_id = t2.department_id);

/*multicolumn subquery*/
select * from employees where (salary,job_id) in (select min_salary,job_id from jobs);

/*inline views*/
 select * from (select department_id,count(*) emp_count from employees group by department_id) emp 
 join departments dept on emp.department_id=dept.department_id;
 
 select * from (select * from employees where commission_pct is null order by salary desc) where rownum <= 3;
 
 /*index*/
select * from employees where salary between 24000 and 25000;
--create index empl_idx2 on employees (salary,hire_date);
select * from employees where salary between 24000 and 25000 and hire_date < sysdate-365;
--drop index empl_idx2;

--select table_name from dict where table_name like '%TRIGGER';
--SELECT * FROM user_ind_columns where table_name='EMPLOYEES';
--SELECT USERNAME,PROGRAM,MACHINE FROM v$session;
--select * from v$instance;
--select * from v$lock;
--select * from all_users;

/*Transaction and transaction locks*/
/*in oracle if user1 updates a row but does not commit, user2 will not see the changes until user1 commits*/
select * from employees where employee_id=100;
--update employees set salary = 2500 where employee_id=100;
/*if user1 modifies row1, user2 tries to update row1, user2 will "forever hang" until user1 commits */

/*Sequences*/
--create sequence my_seq1
--MINVALUE 1
--MAXVALUE 9999999
--START with 1
--INCREMENT BY 1
--CACHE 20;

--select MY_SEQ1.nextval from dual;--this command will increment the sequence everytime it is ran.
--select MY_SEQ1.currval from dual;-- this command will display the current number the sequence is on.
/*my_seq1 is independent from my_seq2*/
--CREATE SEQUENCE my_seq2
--MINVALUE 1
--MAXVALUE 9999999
--START with 1
--INCREMENT BY 1
--CACHE 20;

--create table my_suppliers (supplier_id number(10), supplier_name varchar2(50));
/*
insert into my_suppliers values (my_seq1.nextval, 'apple');
insert into my_suppliers values (my_seq1.nextval, 'google');
insert into my_suppliers values (my_seq1.nextval, 'microsoft');
*/
select * from my_suppliers;
--drop sequence my_seq1;
select * from my_suppliers;

/*identity columns*/-- built-in sequences column

/*CREATE TABLE identity_test1( id NUMBER GENERATED ALWAYS AS IDENTITY, description varchar2(50) );
-- generated always as identity prevents from directly entering an ID (see hello world 4 insert)
insert into identity_test1 (description) values ('Hello World1');
insert into identity_test1 (description) values ('Hello World2');
insert into identity_test1 (description) values ('Hello World3');
insert into identity_test1 (id,description) values (100,'Hello World4');-- cant be inserted bcuz of the id always generated as identity
*/
select * from identity_test1;

--CREATE TABLE identity_test2( id NUMBER GENERATED BY DEFAULT AS IDENTITY, description varchar2(50) );
--the GENERATED BY DEFAULT AS IDENTITY lets us manually manipulate the id if needed.
--INSERT INTO IDENTITY_TEST2 (DESCRIPTION) VALUES ('hello world2');
--INSERT INTO IDENTITY_TEST2 (id,DESCRIPTION) VALUES (2,'hello world1');
--INSERT INTO IDENTITY_TEST2 (id,DESCRIPTION) VALUES (2,'hello world1');

select * from identity_test2;

--CREATE TABLE identity_test3 ( id NUMBER GENERATED BY DEFAULT AS IDENTITY(START WITH 100 INCREMENT BY 10), description varchar2(50) );
--IDENITY COLUMN starts at 100 and increments by 10.
--INSERT INTO IDENTITY_TEST3 (DESCRIPTION) VALUES ('hello world1!');
--INSERT INTO IDENTITY_TEST3 (DESCRIPTION) VALUES ('hello world2!');

SELECT * FROM IDENTITY_TEST3;

--select table_name,column_name,generation_type, identity_options from user_tab_identity_cols order by 1,2;-- lets you see what sequences we have

/*TRIGGERS*/
/*
TRIGGERS TYPES - https://docs.oracle.com/cd/B12037_01/server.101/b10759/statements_1001.htm#i2099257
DML - statements that modify data in a table (insert,update, or delete)
    e.g. (CALL,DELETE,EXPLAIN PLAN,INSERT,LOCK TABLE,MERGE,SELECT,UPDATE)

DDL statements
    Create, alter, and drop schema objects
    Grant and revoke privileges and roles
    Analyze information on a table, index, or cluster
    Establish auditing options
    Add comments to the data dictionary

SYSTEMS EVENTS, such as startup, shutdown, and error messages

USER EVENTS, such as logon and logoff
*/

/*TRIGGERS*/
--create table table1 ( col1 number(5), col2 varchar2(50) );
--create table table2 ( col1 number(5), col2 varchar2(50) );
--    CREATE OR REPLACE TRIGGER test_trg1
--    AFTER INSERT ON table1
--    FOR EACH ROW
--    BEGIN
--        INSERT INTO table2 values (:new.col1,:new.col2);
--    END;

Select * from table1;
Select * from table2;

--insert into table1 values (1,'Hello World!');--inserts value into table1 and trigger populates table2

--CREATE TABLE audit_table ( op_time date, col1 number(5), col2_before VARCHAR2(50), col2_after varchar2(50) );
    --CREATE OR REPLACE TRIGGER audit_trg
    --AFTER INSERT OR DELETE OR UPDATE ON table1
    --FOR EACH ROW
    --BEGIN
    --    insert into audit_table values (sysdate, :new.col1, :old.col2, :new.col2);
    --END;

--UPDATE table1 SET col2='Hello World 9' WHERE col1=1;
SELECT * FROM audit_table;

/*Procedures PL/SQL*/
/*
    CREATE PROCEDURE hr.update_emp_sal1 (P_EMP_ID IN NUMBER, SAL_RAISE IN NUMBER)
    AS
        V_EMP_CURRENT_SAL NUMBER;
    BEGIN
    SELECT SALARY INTO V_EMP_CURRENT_SAL FROM EMPLOYEES
    WHERE EMPLOYEE_ID=P_EMP_ID;
    
        UPDATE employees
        SET salary=V_EMP_CURRENT_SAL+SAL_RAISE
        WHERE employee_id=P_EMP_ID;
        
        EXCEPTION WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR (-20001,'An error was encountered - ' ||SQLCODE|| 'ERROR - ' || SQLERRM);
            ROLLBACK;
        COMMIT;
    END;
*/
/*FUNCTION PL/SQL*/
    /*
    CREATE OR REPLACE FUNCTION hr.period_of_service_year (P_EMP_ID NUMBER)
    RETURN NUMBER
    AS
        V_PERIOD_OF_SERVICE_YEARS NUMBER;
    BEGIN
    SELECT EXTRACT(YEAR FROM SYSDATE) - EXTRACT (YEAR FROM TO_DATE(hire_date)) INTO 
        V_PERIOD_OF_SERVICE_YEARS
        FROM employees
        WHERE employee_id=P_EMP_ID;
        
        RETURN V_PERIOD_OF_SERVICE_YEARS;
    END;
    */
/* functions as invoked from within a sql query
SELECT EMPLOYEE_ID, FIRST_NAME, period_of_service_year_(EMPLOYEE_ID) FROM EMPOYEES;
*/

/*
PL/SQL:Packages
can contain procedures, fucntions, types, variables, etc.
*/
--    CREATE PACKAGE customer_sal AS
--        PROCEDURE find_salary (cust_id customer.id%type);
--    END customer_sal;
--    /
--    CREATE PACKAGE BODY customer_sal AS
--        PROCEDURE find_salary (cust_id customer.id%TYPE) IS
--        c_sal customer.salary%TYPE;
--        BEGIN
--            ...
--        END find_sal;
--    END customer_sal;
--    /
/*
    CREATE OR REPLACE PROCEDURE proc1 (emp_id IN NUMBER)
    IS
        emp_fname VARCHAR2(50);
    BEGIN
        SELECT first_name INTO emp_fname FROM employees WHERE employee_id=emp_id;
        DBMS_OUTPUT.PUT_LINE('Employee name is: ' || emp_fname);
    END;
*/
--SET SERVEROUTPUT ON /*this turns out the ability to print to the user's terminal via "DBMS_OUTPUT.PUT_LINE" in the proc*/
EXEC proc1(100);

--    CREATE OR REPLACE FUNCTION func1 (emp_id IN NUMBER)
--    RETURN VARCHAR2
--    IS emp_fname VARCHAR2(50);
--    BEGIN
--        SELECT first_name INTO emp_fname FROM employees WHERE employee_id=emp_id;
--        RETURN emp_fname;
--    END;

SELECT func1(100) FROM dual; --dual is the dummy table.

/*synonyms*/
create synonym emp for hr.employees;

select * from emp where employee_id = 100;

drop synonym emp;

/*views*/
create or replace view emp_sales
as
select * from employees where job_id='SA_MAN';

select * from emp_sales;
/*bascially select * from (select * from employees where job_id='SA_MAN'); */
/*complex views*/
Select emp_sales.first_name, departments.department_name
From emp_sales join departments ON emp_sales.department_id = departments.department_id;

CREATE OR REPLACE VIEW locations_view
AS
SELECT d.department_id, d.department_name, i.location_id, i.city
FROM departments d, locations i
WHERE d.location_id = i.location_id;

SELECT * FROM locations_view;

/*drop view locations_view;*/

/*Table Partitions*/
/*
. LIST: partitions based on "states" 
. RANGE: partitions based on ranges of data. ie Jan 2019, Feb 2019
. HASH
. INTERVAL
. COMPOSITE
. AUTOMATIC LIST
*/
--drop table sale_list;
CREATE TABLE sale_list
(
salesrep_id NUMBER(5),
salesrep_name VARCHAR2(40),
sales_state VARCHAR2(30),
sales_value NUMBER(10),
sales_date DATE
)
PARTITION BY LIST(sales_state)/*needs to be added when table created*/
(
PARTITION sales_CA VALUES('CA'),
PARTITION sales_NY VALUES('NY'),
PARTITION sales_central VALUES('TX','IL'),
PARTITION sales_other VALUES(DEFAULT)
);

--INSERT INTO sale_list VALUES (100,'Picard','CA',100,'01-JAN-2017');
--INSERT INTO sale_list VALUES (200,'Janeway','NY',500,'02-JAN-2017');
--INSERT INTO sale_list VALUES (300,'Kirk','TX',1000,'03-JAN-2017');
--INSERT INTO sale_list VALUES (100,'Picard','IL',500,'04-JAN-2017');

SELECT * FROM sale_list;

SELECT * FROM sale_list PARTITION (sales_ca);
SELECT * FROM sale_list PARTITION (sales_ny);
SELECT * FROM sale_list PARTITION (sales_central);
SELECT * FROM sale_list PARTITION (sales_other);

--INSERT INTO sale_list VALUES (200,'Janeway','FL',999,'05-JAN-2017');

/*split a partition*/
ALTER TABLE sale_list
SPLIT PARTITION sales_other VALUES ('NV')
INTO (
PARTITION sales_NV,
PARTITION sales_other
);

SELECT * FROM sale_list PARTITION (sales_NV);

/*range partitions*/
CREATE TABLE sales_range
(
salesrep_id NUMBER(5),
salesrep_name VARCHAR2(30),
sales_amount NUMBER(10),
sales_date DATE
)
PARTITION BY RANGE(sales_date)
(
PARTITION sales_jan2017 VALUES LESS THAN(TO_DATE('01/02/2017','DD/MM/YYYY')),/* upper MONTH = FEB.*/
PARTITION sales_feb2017 VALUES LESS THAN(TO_DATE('01/03/2017','DD/MM/YYYY')),
PARTITION sales_mar2017 VALUES LESS THAN(TO_DATE('01/04/2017','DD/MM/YYYY')),
PARTITION sales_apr2017 VALUES LESS THAN(TO_DATE('01/05/2017','DD/MM/YYYY'))
);

--INSERT INTO sales_range VALUES (100,'Picard',100,'01-JAN-2017');
--INSERT INTO sales_range VALUES (200,'Janeway',500,'01-FEB-2017');
--INSERT INTO sales_range VALUES (300,'Kirk',100,'01-MAY-2017');

SELECT * FROM sales_range partition (sales_jan2017);
SELECT * FROM sales_range partition (sales_feb2017);
SELECT * FROM sales_range partition (sales_feb2017);

--ALTER TABLE sales_range ADD PARTITION sales_may2017 VALUES LESS THAN(TO_DATE('01/06/2017','DD/MM/YYYY'));

/*HASH PARTITIONS*/
CREATE TABLE sales_hash
(
salesrep_id NUMBER(5),
salesrep_name VARCHAR2(30),
sales_amount NUMBER(10),
sale_no NUMBER(5)
)
PARTITION BY HASH(sale_no)
PARTITIONS 4;

ANALYZE TABLE sales_hash COMPUTE STATISTICS;

SELECT table_name, partition_name, num_rows
FROM user_tab_partitions
WHERE table_name = 'SALES_HASH';

--INSERT INTO sales_hash VALUES (100,'Picard',500,1423);
ANALYZE TABLE sales_hash COMPUTE STATISTICS;

--INSERT INTO sales_hash VALUES (100,'Picard',600,1424);
--INSERT INTO sales_hash VALUES (100,'Picard',700,1425);
--INSERT INTO sales_hash VALUES (100,'Picard',800,1426);
--INSERT INTO sales_hash VALUES (100,'Picard',900,1427);
--INSERT INTO sales_hash VALUES (100,'Picard',1000,1428);
--INSERT INTO sales_hash VALUES (100,'Picard',1100,1429);
--INSERT INTO sales_hash VALUES (100,'Picard',1200,1430);
--INSERT INTO sales_hash VALUES (100,'Picard',1300,1431);

Select * from sales_hash;
